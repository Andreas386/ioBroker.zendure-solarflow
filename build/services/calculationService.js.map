{
  "version": 3,
  "sources": ["../../src/services/calculationService.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/indent */\r\n\r\nimport { toHoursAndMinutes } from \"../helpers/timeHelper\";\r\nimport { ZendureSolarflow } from \"../main\";\r\nimport { ISolarFlowDeviceDetails } from \"../models/ISolarFlowDeviceDetails\";\r\n\r\nconst calculationStateKeys = [\r\n  \"packInput\",\r\n  \"outputHome\",\r\n  \"outputPack\",\r\n  \"solarInput\",\r\n];\r\n\r\nexport const setEnergyWhMax = async (\r\n  adapter: ZendureSolarflow,\r\n  productKey: string,\r\n  deviceKey: string,\r\n): Promise<void> => {\r\n  const currentEnergyState = await adapter?.getStateAsync(\r\n    productKey + \".\" + deviceKey + \".calculations.energyWh\",\r\n  );\r\n\r\n  if (currentEnergyState) {\r\n    await adapter?.setStateAsync(\r\n      `${productKey}.${deviceKey}.calculations.energyWhMax`,\r\n      currentEnergyState?.val,\r\n      true,\r\n    );\r\n  }\r\n};\r\n\r\nexport const calculateSocAndEnergy = async (\r\n  adapter: ZendureSolarflow,\r\n  productKey: string,\r\n  deviceKey: string,\r\n  stateKey: string,\r\n  value: number,\r\n): Promise<void> => {\r\n  const currentEnergyState = await adapter?.getStateAsync(\r\n    productKey + \".\" + deviceKey + \".calculations.energyWh\",\r\n  );\r\n\r\n  const currentEnergyMaxState = await adapter?.getStateAsync(\r\n    productKey + \".\" + deviceKey + \".calculations.energyWhMax\",\r\n  );\r\n\r\n  const currentValue = currentEnergyState?.val\r\n    ? Number(currentEnergyState?.val)\r\n    : 0;\r\n\r\n  const newValue =\r\n    stateKey == \"outputPack\" ? currentValue + value : currentValue - value;\r\n\r\n  if (newValue > 0) {\r\n    adapter?.setState(\r\n      `${productKey}.${deviceKey}.calculations.energyWh`,\r\n      newValue,\r\n      true,\r\n    );\r\n\r\n    if (currentEnergyMaxState) {\r\n      const soc = Number(\r\n        ((newValue / Number(currentEnergyMaxState.val)) * 100).toFixed(1),\r\n      );\r\n\r\n      await adapter?.setStateAsync(\r\n        `${productKey}.${deviceKey}.calculations.soc`,\r\n        soc > 100.0 ? 100 : soc,\r\n        true,\r\n      );\r\n\r\n      if (newValue > Number(currentEnergyMaxState.val)) {\r\n        // Extend maxVal\r\n        await adapter?.setStateAsync(\r\n          `${productKey}.${deviceKey}.calculations.energyWhMax`,\r\n          newValue,\r\n          true,\r\n        );\r\n      }\r\n\r\n      if (stateKey == \"outputPack\") {\r\n        // Charging, calculate remaining charging time\r\n        const toCharge = Number(currentEnergyMaxState.val) - newValue;\r\n\r\n        const remainHoursAsDecimal = toCharge / value;\r\n        const remainFormatted = toHoursAndMinutes(remainHoursAsDecimal * 60);\r\n\r\n        await adapter?.setStateAsync(\r\n          `${productKey}.${deviceKey}.calculations.remainInputTime`,\r\n          remainFormatted,\r\n          true,\r\n        );\r\n      } else if (stateKey == \"packInput\") {\r\n        // Discharging, calculate remaining discharge time\r\n        const remainHoursAsDecimal = newValue / value;\r\n        const remainFormatted = toHoursAndMinutes(remainHoursAsDecimal * 60);\r\n\r\n        await adapter?.setStateAsync(\r\n          `${productKey}.${deviceKey}.calculations.remainInputTime`,\r\n          remainFormatted,\r\n          true,\r\n        );\r\n      }\r\n    } else {\r\n      await adapter?.setStateAsync(\r\n        `${productKey}.${deviceKey}.calculations.energyWhMax`,\r\n        newValue,\r\n        true,\r\n      );\r\n    }\r\n  }\r\n};\r\n\r\nexport const calculateEnergy = async (\r\n  adapter: ZendureSolarflow,\r\n  productKey: string,\r\n  deviceKey: string,\r\n): Promise<void> => {\r\n  calculationStateKeys.forEach(async (stateKey) => {\r\n    const stateNameEnergyWh = `${productKey}.${deviceKey}.calculations.${stateKey}EnergyTodayWh`;\r\n    const stateNameEnergykWh = `${productKey}.${deviceKey}.calculations.${stateKey}EnergyTodaykWh`;\r\n    const stateNamePower = `${productKey}.${deviceKey}.${stateKey}Power`;\r\n\r\n    const currentPowerState = await adapter?.getStateAsync(stateNamePower);\r\n    const currentEnergyState = await adapter?.getStateAsync(stateNameEnergyWh);\r\n\r\n    if (currentEnergyState?.val == 0) {\r\n      // Workaround, set Val to very low value to avoid Jump in data...\r\n      await adapter?.setStateAsync(stateNameEnergyWh, 0.000001, true);\r\n    } else if (\r\n      currentEnergyState &&\r\n      currentEnergyState.lc &&\r\n      currentPowerState &&\r\n      currentPowerState.val != undefined &&\r\n      currentPowerState.val != null\r\n    ) {\r\n      // Timeframe = 30000ms, Job runs every 30 seconds...\r\n      const timeFrame = 30000;\r\n\r\n      // Calculate Energy value (Wh) from current power in the timeframe from last run...\r\n      let addEnergyValue =\r\n        (Number(currentPowerState.val) * timeFrame) / 3600000; // Wh\r\n\r\n      // Use efficiency factor (used the one from Youtube Channel VoltAmpereLux - thanks!)\r\n      const chargingFactor = 0.96; // Efficiency 96%\r\n      const dischargingFactor = 1.08 - addEnergyValue / 10000; // Efficiency 92% - 98% (92% + Energy / 10000 = 600W -> +6%)\r\n\r\n      // Calculate energy from efficiency factor if value for charging or discharging\r\n      addEnergyValue =\r\n        stateKey == \"outputPack\" && addEnergyValue > 0\r\n          ? addEnergyValue * chargingFactor\r\n          : addEnergyValue;\r\n      addEnergyValue =\r\n        stateKey == \"packInput\" && addEnergyValue > 0\r\n          ? addEnergyValue * dischargingFactor\r\n          : addEnergyValue;\r\n\r\n      let newEnergyValue = Number(currentEnergyState.val) + addEnergyValue;\r\n\r\n      // Fix negative value\r\n      if (newEnergyValue < 0) {\r\n        newEnergyValue = 0;\r\n      }\r\n\r\n      await adapter?.setStateAsync(stateNameEnergyWh, newEnergyValue, true);\r\n      await adapter?.setStateAsync(\r\n        stateNameEnergykWh,\r\n        Number((newEnergyValue / 1000).toFixed(2)),\r\n        true,\r\n      );\r\n\r\n      // SOC and energy in batteries\r\n      if (\r\n        (stateKey == \"outputPack\" || stateKey == \"packInput\") &&\r\n        addEnergyValue > 0\r\n      ) {\r\n        await calculateSocAndEnergy(\r\n          adapter,\r\n          productKey,\r\n          deviceKey,\r\n          stateKey,\r\n          addEnergyValue,\r\n        );\r\n      }\r\n    } else {\r\n      await adapter?.setStateAsync(stateNameEnergyWh, 0, true);\r\n      await adapter?.setStateAsync(stateNameEnergykWh, 0, true);\r\n    }\r\n  });\r\n};\r\n\r\nexport const resetTodaysValues = async (\r\n  adapter: ZendureSolarflow,\r\n): Promise<void> => {\r\n  adapter.deviceList.forEach((device: ISolarFlowDeviceDetails) => {\r\n    calculationStateKeys.forEach(async (stateKey: string) => {\r\n      const stateNameEnergyWh = `${device.productKey}.${device.deviceKey}.calculations.${stateKey}EnergyTodayWh`;\r\n      const stateNameEnergykWh = `${device.productKey}.${device.deviceKey}.calculations.${stateKey}EnergyTodaykWh`;\r\n\r\n      await adapter?.setStateAsync(stateNameEnergyWh, 0, true);\r\n      await adapter?.setStateAsync(stateNameEnergykWh, 0, true);\r\n    });\r\n  });\r\n};\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,wBAAkC;AAIlC,MAAM,uBAAuB;AAAA,EAC3B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAEO,MAAM,iBAAiB,OAC5B,SACA,YACA,cACkB;AAClB,QAAM,qBAAqB,OAAM,mCAAS;AAAA,IACxC,aAAa,MAAM,YAAY;AAAA;AAGjC,MAAI,oBAAoB;AACtB,WAAM,mCAAS;AAAA,MACb,GAAG,UAAU,IAAI,SAAS;AAAA,MAC1B,yDAAoB;AAAA,MACpB;AAAA;AAAA,EAEJ;AACF;AAEO,MAAM,wBAAwB,OACnC,SACA,YACA,WACA,UACA,UACkB;AAClB,QAAM,qBAAqB,OAAM,mCAAS;AAAA,IACxC,aAAa,MAAM,YAAY;AAAA;AAGjC,QAAM,wBAAwB,OAAM,mCAAS;AAAA,IAC3C,aAAa,MAAM,YAAY;AAAA;AAGjC,QAAM,gBAAe,yDAAoB,OACrC,OAAO,yDAAoB,GAAG,IAC9B;AAEJ,QAAM,WACJ,YAAY,eAAe,eAAe,QAAQ,eAAe;AAEnE,MAAI,WAAW,GAAG;AAChB,uCAAS;AAAA,MACP,GAAG,UAAU,IAAI,SAAS;AAAA,MAC1B;AAAA,MACA;AAAA;AAGF,QAAI,uBAAuB;AACzB,YAAM,MAAM;AAAA,SACR,WAAW,OAAO,sBAAsB,GAAG,IAAK,KAAK,QAAQ,CAAC;AAAA,MAClE;AAEA,aAAM,mCAAS;AAAA,QACb,GAAG,UAAU,IAAI,SAAS;AAAA,QAC1B,MAAM,MAAQ,MAAM;AAAA,QACpB;AAAA;AAGF,UAAI,WAAW,OAAO,sBAAsB,GAAG,GAAG;AAEhD,eAAM,mCAAS;AAAA,UACb,GAAG,UAAU,IAAI,SAAS;AAAA,UAC1B;AAAA,UACA;AAAA;AAAA,MAEJ;AAEA,UAAI,YAAY,cAAc;AAE5B,cAAM,WAAW,OAAO,sBAAsB,GAAG,IAAI;AAErD,cAAM,uBAAuB,WAAW;AACxC,cAAM,sBAAkB,qCAAkB,uBAAuB,EAAE;AAEnE,eAAM,mCAAS;AAAA,UACb,GAAG,UAAU,IAAI,SAAS;AAAA,UAC1B;AAAA,UACA;AAAA;AAAA,MAEJ,WAAW,YAAY,aAAa;AAElC,cAAM,uBAAuB,WAAW;AACxC,cAAM,sBAAkB,qCAAkB,uBAAuB,EAAE;AAEnE,eAAM,mCAAS;AAAA,UACb,GAAG,UAAU,IAAI,SAAS;AAAA,UAC1B;AAAA,UACA;AAAA;AAAA,MAEJ;AAAA,IACF,OAAO;AACL,aAAM,mCAAS;AAAA,QACb,GAAG,UAAU,IAAI,SAAS;AAAA,QAC1B;AAAA,QACA;AAAA;AAAA,IAEJ;AAAA,EACF;AACF;AAEO,MAAM,kBAAkB,OAC7B,SACA,YACA,cACkB;AAClB,uBAAqB,QAAQ,OAAO,aAAa;AAC/C,UAAM,oBAAoB,GAAG,UAAU,IAAI,SAAS,iBAAiB,QAAQ;AAC7E,UAAM,qBAAqB,GAAG,UAAU,IAAI,SAAS,iBAAiB,QAAQ;AAC9E,UAAM,iBAAiB,GAAG,UAAU,IAAI,SAAS,IAAI,QAAQ;AAE7D,UAAM,oBAAoB,OAAM,mCAAS,cAAc;AACvD,UAAM,qBAAqB,OAAM,mCAAS,cAAc;AAExD,SAAI,yDAAoB,QAAO,GAAG;AAEhC,aAAM,mCAAS,cAAc,mBAAmB,MAAU;AAAA,IAC5D,WACE,sBACA,mBAAmB,MACnB,qBACA,kBAAkB,OAAO,UACzB,kBAAkB,OAAO,MACzB;AAEA,YAAM,YAAY;AAGlB,UAAI,iBACD,OAAO,kBAAkB,GAAG,IAAI,YAAa;AAGhD,YAAM,iBAAiB;AACvB,YAAM,oBAAoB,OAAO,iBAAiB;AAGlD,uBACE,YAAY,gBAAgB,iBAAiB,IACzC,iBAAiB,iBACjB;AACN,uBACE,YAAY,eAAe,iBAAiB,IACxC,iBAAiB,oBACjB;AAEN,UAAI,iBAAiB,OAAO,mBAAmB,GAAG,IAAI;AAGtD,UAAI,iBAAiB,GAAG;AACtB,yBAAiB;AAAA,MACnB;AAEA,aAAM,mCAAS,cAAc,mBAAmB,gBAAgB;AAChE,aAAM,mCAAS;AAAA,QACb;AAAA,QACA,QAAQ,iBAAiB,KAAM,QAAQ,CAAC,CAAC;AAAA,QACzC;AAAA;AAIF,WACG,YAAY,gBAAgB,YAAY,gBACzC,iBAAiB,GACjB;AACA,cAAM;AAAA,UACJ;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF,OAAO;AACL,aAAM,mCAAS,cAAc,mBAAmB,GAAG;AACnD,aAAM,mCAAS,cAAc,oBAAoB,GAAG;AAAA,IACtD;AAAA,EACF,CAAC;AACH;AAEO,MAAM,oBAAoB,OAC/B,YACkB;AAClB,UAAQ,WAAW,QAAQ,CAAC,WAAoC;AAC9D,yBAAqB,QAAQ,OAAO,aAAqB;AACvD,YAAM,oBAAoB,GAAG,OAAO,UAAU,IAAI,OAAO,SAAS,iBAAiB,QAAQ;AAC3F,YAAM,qBAAqB,GAAG,OAAO,UAAU,IAAI,OAAO,SAAS,iBAAiB,QAAQ;AAE5F,aAAM,mCAAS,cAAc,mBAAmB,GAAG;AACnD,aAAM,mCAAS,cAAc,oBAAoB,GAAG;AAAA,IACtD,CAAC;AAAA,EACH,CAAC;AACH;",
  "names": []
}
